#!/usr/bin/env perl

use strict;
use warnings;
use autodie;
use feature qw< state >;
use Getopt::Long;
use URI;

## Argument processing.

my $add_header_toggles;

GetOptions(
		   "--add-header-toggles" => \$add_header_toggles,
		  );

my $toggle_js = <<"EOF";
<script type="text/javascript">
<!--
    function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'none')
          e.style.display = 'block';
       else
          e.style.display = 'none';
    }
//-->
</script>
EOF

## Global Variables.

my @output;
my @toc_lines;
my $toc_exclude_pat;
my $toc_min = 0;
my $toc_max = 10;

my $wiki_link_pat            = qq{[:alnum:]&|\,/\-:. };
my $header_link_pat          = qq{$wiki_link_pat#-};
my $external_link_text_pat   = qq{[:alnum:]:"'\\.,\\?#!\\-\~\%&@\+\(\) };
my $external_link_target_pat = qq{$external_link_text_pat\_/:=&};
my $image_pat                = qq{[:alnum:]%\\-|\\.:/ };
my $bold_pat                 = qq{[:alnum:]+_!@#$%^\(\)+\\-&,:;=`'?>\\.\\\/" };
my $italic_pat               = qq{[:alnum:]+!@#$%^\(\)+\\-&,:;=`'?>\\.\\\/" };
my $panel_pat                = "{panel.*";
my $toc_pat                  = "{toc.*";

## Ye Olde Main Input Processing Loop.

push @output, $toggle_js if $add_header_toggles;
my $toggled_header_seen = 0;

LINE: while (<>) {
    state $code        = 0;
    state $info        = 0;
    state $tip         = 0;
    state $note        = 0;
    state $warning     = 0;
    state $htmlcomment = 0;
    state $table       = 0;
    state $quote       = 0;

    next LINE if /$panel_pat/;

    if (/$toc_pat/) {
        push @output, $_;
        next LINE;
    }

    ## We wrap the code below in a DO block so that text is never
    ## modified in any way while we're inside a `{code}' block.  This
    ## change was prompted by two things (so far):
    ##  1. An attempt to format some Objective-C code in one of our
    ## projects.
    ##  2. The need to be able to write a page in Confluence markup
    ## with some examples of Confluence markup wrapped in `{code}'
    ## blocks.

    do {
      # Add a horizontal rule.
      s{^----$}{<hr></hr>};

      # External links with custom text, e.g., `[a sample website|http://example.com]'.
      s{\[([$external_link_text_pat]+)\|([$external_link_target_pat]+)\]}
       {<a href="$2">$1</a>}gis;

      # Plain external links, e.g., `[http://example.com]'.
      s{\[([$external_link_target_pat]+)\]}{ check_for_uri($1)  }ge;

      # Internal links, e.g. `[Mobile Ad Call Reference]'.  See below
      # for the definition of EUNICIZE.
      s{\[([$wiki_link_pat]+)\]}
       {qq[<a href="] . eunicize($1) . qq[">$1</a>]}gise;

      # Links to headers on the same page.  We don't support anchors
      # (yet).
      s{\[#([$header_link_pat]+)\]}
       {<a href="#$1">$1</a>}gis;

      # Images.
      s{^\!([$image_pat]+.(png|jpg)).*\!}{<br /><br /><img src="$1"/><br /><br />}gis;

      # Lists of links, optionally followed by a colon or slash, then
      # descriptive text.
      s/^\* ?(<a href.*<\/a>)([ :\-]?.*)/\<li>$1$2<\/li>/g;
      s/^[0-9]\. ?(<a href.*<\/a>)([ :\-]?.*)/\<li class="ordered">$1$2<\/li>/g;

      # Lists of non-link items.
      s/^\*( +.*)$/\<li>$1<\/li>/g;
      s/^[0-9]\.( +.*)$/\<li class="ordered">$1<\/li>/g;

      # Bold elements (Sometimes they occur at the beginning of a
      # line, so we process them before we get to the list section
      # below.
      s/\*([$bold_pat]+)\*/<strong>$1<\/strong>/g;
      s/^\*([$bold_pat]+)\*/<strong>$1<\/strong>/g;


      # Italic elements.
      s/( +|^|\(|\[)\_([$italic_pat]+)\_/$1<em>$2<\/em>/g;

      # Tables.  These still have to be wrapped in a `{table}' macro.
      # Hopefully not for long.
      s{^\|\|}{<tr><th>}gis;    # Beginning of table
      s{\|\| ?\n}{</th></tr>}gis;
      s{\|\|}{</th><th>}gis;         # Middle of columns
      s{\| ?\n$}{</td></tr>}gis;     # End of table row
      s{^\|}{<tr><td>}gis;
      s{\|}{</td><td>}gis;

    # Process headers, 1-6.  We add an appropriate ID to each header's
    # LI tag so that we can use CSS's TEXT-INDENT to create a nice
    # indentation in the table of contents.

    if (/h([0-9]). (.*)$/) {
	  my $new;
	  if ($add_header_toggles and $1 eq "2") {
        $toggled_header_seen++;
		my $rand = int rand 99999;
		$new = <<"EOF";
<h$1><a name="$2-TOC"><a href="#-$rand" onclick="toggle_visibility('$2');">&gt;</a>&nbsp;$2</a></h$1>
<div id="$2" style="display: none">
EOF
        $new = '</div> ' . $new if $toggled_header_seen > 1;
	  }
	  else {
		$new = qq[<h$1><a name="$2-TOC">$2</a></h$1>];
	  }
	  my $toc_line = qq[<li class="h$1"><a href="#$2-TOC">$2</a></li>];
	  push @toc_lines, [ $1, $toc_line ];
	  s/h$1. (.*)$/$new/;
    }

    # Monospace.
    s/{{{?([\[\]\/\\!\?&\@\^\=\#\$0-9\+\*A-Z\.,\-\/>a-z_=:%`'"~\(\) \<\>\n]+}?)}}/<code>$1<\/code>/g;

    # Same-line code blocks.
    s/\{code\}\n?(.*[\n]?)\n?\{code\}/<pre>$1<\/pre>/s;

    } unless $code % 2 != 0;

    # Multiline code blocks.
    $code++ if /\{code\}/;

    if ( $code % 2 != 0 ) {
      # Escape embedded HTML/XML tags inside the code block.  This was
      # necessitated by some XML build cruft for an Android project.
        s/</&lt;/g;
        s/>/&gt;/g;
        s/\{code\}/<pre>/;
    }
    elsif ( $code % 2 == 0 ) {
        s/\{code\}/<\/pre>/;
    }

    # Div-ify the Confluence macros INFO, NOTE, TIP, and WARNING so
    # that we can give them the appropriate colors using CSS.
    $info++ if /{info}/;
    if ( $info % 2 != 0 ) {
        s/{info}/<div class="info">/;
    }
    elsif ( $info % 2 == 0 ) {
        s/{info}/<\/div>/;
    }

    $note++ if /{note}/;
    if ( $note % 2 != 0 ) {
        s/{note}/<div class="note">/;
    }
    elsif ( $note % 2 == 0 ) {
        s/{note}/<\/div>/;
    }

    $tip++ if /{tip}/;
    if ( $tip % 2 != 0 ) {
        s/{tip}/<div class="tip">/;
    }
    elsif ( $tip % 2 == 0 ) {
        s/{tip}/<\/div>/;
    }

    $warning++ if /{warning}/;
    if ( $warning % 2 != 0 ) {
        s/{warning}/<div class="warning">/;
    }
    elsif ( $warning % 2 == 0 ) {
        s/{warning}/<\/div>/;
    }

    $quote++ if /{quote}/;
    if ( $quote % 2 != 0 ) {
        s/{quote}/<blockquote>/;
    }
    elsif ( $quote % 2 == 0 ) {
        s/{quote}/<\/blockquote>/;
    }
    # Support HTML comments. This is one of my favorite macros.
    $htmlcomment++ if /{htmlcomment}/;
    if ( $htmlcomment % 2 != 0 ) {
        s/{htmlcomment}/<!--/;
    }
    elsif ( $htmlcomment % 2 == 0 ) {
        s/{htmlcomment}/-->/;
    }

    # HTML tables need to be wrapped in `{table}' tags.
    $table++ if /{table}/;
    if ( $table % 2 != 0 ) {
        s/{table}/<table>/;
    }
    elsif ( $table % 2 == 0 ) {
        s/{table}/\n<\/table>/;
    }

    # Encode ampersands.
    s/ & / &amp; /g;

    # We know that lines containing headers, tables, and some other
    # types of HTML are not appropriate candidates to be wrapped in
    # paragraph tags, so we push those lines into the output buffer
    # without any further processing.

    if (/(<\/?h[0-9]>|<\/?pre>|<\/?table>|<\/?li>|<\/?div)/) {
      push @output, $_;
      next LINE;
    }

    # Since all the other transformations are complete, we now know that we can
    # wrap lines of text that are surrounded by newlines in paragraph tags
    # (with a few simple exceptions).  As above, we wrap this in a DO so that
    # code blocks are not modified.

    do {
      s{^([\w \(\)<\/>\.,`'\-!=;:"\^\+~&\$%#\*@\?{}0-9]+)\n+}{<p>$1</p>}g;
    } unless $code % 2 != 0;

    push @output, $_;
}

push @output, "</div>" if $toggled_header_seen;

# This lets the regex matchers do their thing and close 'ol' tags, etc.
push @output, "\n";

## Ye Olde Main Output Processing Loop.

LINE: for my $line (@output) {
  state $inside_ul = 0;
  state $inside_ol = 0;
  if ( $line =~ /$toc_pat/ ) {
    my @result  = parse_toc($line);
    my $toc_min = $result[0];
    my $toc_max = $result[1];
    my $toc_exclude_pat = $result[2];
    $line = replace_toc_line( $line, $toc_min, $toc_max, $toc_exclude_pat );
  }
  elsif ( $line =~ /<li>/ && ($inside_ul || $inside_ol) ) {
    next LINE;
  }
  elsif ( $line =~ /<li>/ ) {
    $inside_ul = 1;
    $line = "<ul>\n" . $line;
    next LINE;
  }
  elsif ( $line =~ /<li class="ordered">/ && !$inside_ol ) {
    $inside_ol = 1;
    $line = "<ol>\n" . $line;
    next LINE;
  }
  elsif ( $line !~ /<li>/ && $inside_ul ) {
    $inside_ul = 0;
    chomp $line;
    $line .= "</ul>\n";
    next LINE;
  }
  elsif ( $line !~ /<li class="ordered">/ && $inside_ol ) {
    $inside_ol = 0;
    chomp $line;
    $line .= "</ol>\n";
    next LINE;
  }
}

print for @output;

# Turn a [Wiki Link] into a <a href="wiki-link.html">Wiki Link</a>.

sub eunicize {
    # String -> String
    my $title = shift;
    $title =~ s/ /-/g;
    $title =~ s/-{2,}/-/g;
    $title =~ s/[^-\w]//gi;
    $title .= '.html';
    return lc $title;
}

# Check if the thing inside the link text is a URI. If so, make it
# into an HTML link; if not, kick it back out as wiki-formatted link
# text for later processing.

sub check_for_uri {
  # String -> String
  my $it = shift;
  my $retval;

  my $uri    = URI->new($it);
  my $scheme = $uri->scheme;

  if (defined $scheme) {
    $retval = qq{<a href="$it">$it</a>}
  }
  else {
    $retval = qq{[$it]};
  }
}

# Table of contents processing goes here.

sub replace_toc_line {
    # String, Int, Int, Regex -> String
    my ( $line, $min, $max, $pat ) = @_;

    $pat //= "";
    my $result = qq{<div id="toc"><ul>};

    for my $toc_line (@toc_lines) {
        my $line_level = $toc_line->[0];
        my $line_text  = $toc_line->[1];
        if ( ( $min <= $line_level && $line_level <= $max )
            && $line_text !~ $pat )
        {
            $result .= "$line_text\n";
        }
    }
    $result .= qq{</ul></div>};
    $line = $result;
    return $line;
}

sub parse_toc {
    # String -> Array
    # {toc:minlevel=3|maxlevel=4|Exclude=.*} -> ($min, $max, $pat)
    my $s = shift;
    my @result = ( $toc_min, $toc_max, $toc_exclude_pat );
    if ( $s =~ /\{toc:minlevel=(\d+)\|maxlevel=(\d+)\|exclude=(.*)\}/ ) {
        @result = ( $1, $2, $3 );
    }
    elsif ( $s =~ /\{toc:minlevel=(\d)\|maxlevel=(\d).*/ ) {
        @result = ( $1, $2, "3.14159" );
    }
    elsif ( $s =~ /\{toc:minlevel=(\d).*/ ) {
        @result = ( $1, 10, "3.14159" );
    }
    else {
        return @result;
    }

    return @result;
}

__END__

=head1 NAME

confluence2html - Generate HTML from a subset of Confluence wiki markup

=head1 SYNOPSIS

  $ confluence2html < input.txt > output.html

=head1 DESCRIPTION

C<confluence2html> is a command line filter that takes in a stream of
text formatted with a subset of Confluence wiki markup and prints it
out as HTML.  The goal of this project is to provide a reasonable
"publish your writing to HTML" experience for users of Confluence wiki
syntax.

Unlike some other markup languages, this syntax provides features that
are important for technical documents.  For example:

=over

=item Plaintext Table Syntax

You can use Confluence's table syntax instead of having to write HTML
tables by hand.  This matters B<a lot> if you create and maintain
technical documents. (See L</"Tables"> below.)

=item Automatic Tables of Contents

You can use the C<toc> macro to have a nice table of contents
generated for your document.  (See L</"Tables of Contents"> below).

=back

Note that syntax highlighting plugins are available for Vim, Emacs,
and other text editors.

=head1 SUPPORTED MARKUP

The subset of Confluence markup that we support is defined as follows:

=over

=item Headers

The C<h[1-6]> header format is supported, as in C<h2. Introduction>.
No other formatting inside the header text is supported. For example,
C<h2. Introduction to {{confluence2html}}> will not work.

=item Links

Standard links are supported, e.g., C<[Link to some other page on this
wiki]>.  This will be rewritten to link to a local file named
C<link-to-some-other-page-on-this-wiki.html>.  If no such file exists,
this will be a broken link until the file is created.  The easiest
(but not only) way to do this is to have another file of Confluence
markup in the same directory named
C<link-to-some-other-page-on-this-wiki.txt>, which is generated at the
same time.

Note: the HTML output from the "standard link" syntax is still subject
to change.  A more flexible design is needed.  One possibility is to
design several different output formats the user can choose from;
another is to allow the user to pass in a custom formatting tag as an
argument which would allow them to do their own additional processing
on the output, e.g.,

    $ confluence2html --link-tag=LINK < page.txt | MOAR_FILTERING

External links are supported:

    [Perl home page|http://www.perl.org]

    [http://www.example.org]

Confluence space keys are not supported, since the concept of "spaces"
has no meaning in terms of processing a stream of text.  A space
feature could be added by a more sophisticated application built using
this script.

=item Macros

We support only a few of Confluence's many macros -- mainly those that
are required for a reasonable "publish your writing to HTML"
experience.  Here's the list:

=over

=item C<code>

=item C<info>

=item C<tip>

=item C<note>

=item C<warning>

=item C<htmlcomment>

=item C<table>

=item C<toc>

=back

Other than C<toc>, these macros can only be written as single tags on
their own line that delimit blocks of text.  For example:

    {info}
    Have some informative text!
    {info}

No arguments of the form C<{info:title=I am the Title}> are
supported. If you want to add a title your C<info> block for readers,
try something like:

    {info}
    *Important Information!*
    Your coffee is ready.
    {info}

Note that the C<info>, C<tip>, C<note>, C<warning>, and C<toc> macros
output as C<div> tags with class names that correspond to the macro
name for easy CSS styling.  Example output:

    <div class="info">
    <p>These instructions assume that you have already installed and
    correctly configured... For more information, see ... </p>
    </div>

This makes it trivial to add background colors for added emphasis.

=item Tables of Contents

Prints a table of contents with links to some or all headers on the
page.  The following arguments are supported (in addition to none at
all): C<minlevel>, C<maxlevel>, C<exclude> -- and they must be
supplied in that order.  In other words, you must use the C<toc> macro
in one of the following ways:

=over

=item C<{toc}>

Prints a table of contents using all headers on the page.

=item C<{toc:minlevel=$N}>

C<$N> must be an integer between 1 and 6.  This prints a table of
contents with a minimum header size of C<$N>.

=item C<{toc:minlevel=$N|maxlevel=$M}>

C<$N> and C<$M> must be integers between 1 and 6.  This prints a table
of contents with a minimum header size of C<$N> and a maximum header
size of C<$M>.

=item C<{toc:minlevel=$N|maxlevel=$M|exclude=$REGEX}>

C<$N> and C<$M> must be integers between 1 and 6, and C<$REGEX> is a
Perl regular expression -- note that the regular expression is not
surrounded by quotes.  This prints a table of contents with a minimum
header size of C<$N> and a maximum header size of C<$M>, with any
headers matching C<$REGEX> being excluded.

=back

=item Lists

Ordered and unordered lists are supported.  Example:

    * Apple
    * Banana
    * Cherry

    1. Rhubarb
    2. Tomato
    3. Pomegranate

=item line breaks

The line breaks that appear in the HTML output are those that appear
in the text file.  There is no support for the Confluence forced line
break C<\\>.

=item Tables

Tables are supported.  The only requirement is that you must wrap the
table itself in the C<{table}> macro, e.g.:

    {table}
    || Name || Rank || Serial Number ||
    | Steven Fluffernutter | Sergeant | 314159 |
    | Christopher Crunch | Captain | 271828 |
    | ... | ... | ... |
    | ... | ... | ... |
    {table}

Note: Having to wrap tables in the C<table> macro is probably the most
error-prone (and thus annoying) requirement from the perspective of an
experienced Confluence user.  This limitation should be removed in the
future.

=back

=head1 BUGS

Many bugs are lurking in this code; it's a total hack. On the roadmap:
more tests, refactoring, and perhaps even real parsing.

=head1 AUTHOR

Rich Loveland, L<mailto:r@rmloveland.com>
