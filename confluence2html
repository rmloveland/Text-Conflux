#!/usr/bin/env perl

use strict;
use warnings;
use autodie;
use feature qw< say state >;
use Getopt::Long;

#--------------------------------------------------------------------
# Option parsing.

my ( $stylesheet, $wrap );
GetOptions(
    "stylesheet:s" => \$stylesheet,
    "wrap"         => \$wrap,
);

#--------------------------------------------------------------------
# Variables.

my @output;
my @toc_lines;
my $toc_min = 0;
my $toc_max = 10;
my $toc_pat = "3.14159";

my $wiki_link_pat   = "&|/\-:. ";
my $header_link_pat = $wiki_link_pat . "#";

my $external_link_text_pat   = "\\.\\?\\- ";
my $external_link_target_pat = $external_link_text_pat . "#_/:=&";

my $image_pat = "\\-|\\. ";

my $bold_pat   = qq{\\- :>\\.\\"};
my $italic_pat = $bold_pat;

if ($wrap) {
    push @output,
      qq{<html><head><link href="$stylesheet" rel="stylesheet"></head><body>\n};
}

LINE: while (<>) {
    state $code        = 0;
    state $info        = 0;
    state $tip         = 0;
    state $note        = 0;
    state $warning     = 0;
    state $htmlcomment = 0;
    state $table       = 0;
    state $para        = 0;

    next LINE if /{panel.*/;
    if (/{toc.*/) {
        push @output, $_;
        next LINE;
    }

    ## We wrap the below link-making code in a block so that text is
    ## never modified in any way while we're inside a code block.
    ## This was prompted by an attempt to format some Objective-C code
    ## in one of our projects.

    do {
      # External links
      s{\[([[:alnum:]$external_link_text_pat]+)\|([[:alnum:]$external_link_target_pat]+)\]}
       {<a href="$2">$1</a>}gis;

      # Regular wiki links with no space key, e.g. `[Mobile Ad Call Reference]'.
      s{\[([[:alnum:]$wiki_link_pat]+)\]}
       {qq[<a href="] . eunicize($1) . qq[">$1</a>]}gise;

      # Links to headers on the same page
      s{\[#([[:alnum:]$header_link_pat]+)\]}
       {<a href="#$1">$1</a>}gis;

      # Images
      s{^\!([[:alnum:]$image_pat]+.(png|jpg)).*\!}
       {<br /><br /><img src="../img/$1"/><br /><br />}gis;

      # Bold elements
      s/\*([[:alnum:]$bold_pat]+)\*/<strong>$1<\/strong>/g;

      # Lists of links, optionally followed by descriptions
      s/^\* ?(<a href.*<\/a>)([ :\-]?.*)/\<li>$1$2<\/li>/g;

      # Lists of non-link items
      s/^\* ?(.*)$/\<li>$1<\/li>/g;

      # Italic elements
      s/ \_([[:alnum:]$italic_pat]+)\_([ \.])/ <em>$1<\/em>$2/g;

      # Tables
      s{^\|\|}{<tr><th><strong>}gis;    # Beginning of table
      s{\|\| ?\n}{</strong></th></tr>}gis;
      s{\|\|}{<th><strong>}gis;         # Middle of columns
      s{\| ?\n}{</td></tr>}gis;
      s{\|}{<td>}gis;

    } unless $code % 2 != 0;

    # Headers
    if (/h1. (.*)$/) {
        my $new =
          qq[<h1><a name="$1">$1</a></h1>];
        my $toc_line = qq[<li><a href="#$1">$1</a></li>];
        push @toc_lines, [ 1, $toc_line ];
        s/h1. (.*)$/$new/;
    }

    if (/h2. (.*)$/) {
        my $new =
          qq[<h2><a name="$1">$1</a></h2>];
        my $toc_line = qq[<li><a href="#$1">$1</a></li>];
        push @toc_lines, [ 2, $toc_line ];
        s/h2. (.*)$/$new/;
    }

    if (/h3. (.*)$/) {
        my $new = qq[<h3><a name="$1">$1</a></h3>];
        my $toc_line = qq[<li><a href="#$1">$1</a></li>];
        push @toc_lines, [ 3, $toc_line ];
        s/h3. (.*)$/$new/;
    }

    if (/h4. (.*)$/) {
        my $new = qq[<h4><a name="$1">$1</a></h4>];
        my $toc_line = qq[<li><a href="#$1">$1</a></li>];
        push @toc_lines, [ 4, $toc_line ];
        s/h4. (.*)$/$new/;
    }

    if (/h5. (.*)$/) {
        my $new      = qq[<h5><a name="$1">$1</a></h5>];
        my $toc_line = qq[<li><a href="#$1">$1</a></li>];
        push @toc_lines, [ 5, $toc_line ];
        s/h5. (.*)$/$new/;
    }

    if (/h6. (.*)$/) {
        my $new      = qq[<h6><a name="$1">$1</a></h6>];
        my $toc_line = qq[<li><a href="#$1">$1</a></li>];
        push @toc_lines, [ 6, $toc_line ];
        s/h6. (.*)$/$new/;
    }

    # Monospace and code
    s/{{([\\!\@\$0-9\+A-Z\.,\-\/>a-z_=:"\(\) \<\>\n]+)}}/<code>$1<\/code>/g;
    s/\{code\}\n?(.*[\n]?)\n?\{code\}/<pre>$1<\/pre>/s
      ;    # Single line code blocks

    # Multiline code blocks
    $code++ if /\{code\}/;

    if ( $code % 2 != 0 ) {    # Inside code block
                               # Escape embedded XML tags first, if any.
        s/</&lt;/g;
        s/>/&gt;/g;
        s{\n}{}g;
        s/\{code\}/<pre>/;
    }
    elsif ( $code % 2 == 0 ) {    # Close code block
        s/\{code\}/<\/pre>/;
    }

    # Div-ify Confluence macros
    $info++ if /{info}/;
    if ( $info % 2 != 0 ) {
        s/{info}/<div id="info"><p>/;
    }
    elsif ( $info % 2 == 0 ) {
        s/{info}/<\/p><\/div>/;
    }

    $note++ if /{note}/;
    if ( $note % 2 != 0 ) {
        s/{note}/<div id="note"><p>/;
    }
    elsif ( $note % 2 == 0 ) {
        s/{note}/<\/p><\/div>/;
    }

    $tip++ if /{tip}/;
    if ( $tip % 2 != 0 ) {
        s/{tip}/<div id="tip"><p>/;
    }
    elsif ( $tip % 2 == 0 ) {
        s/{tip}/<\/p><\/div>/;
    }

    $warning++ if /{warning}/;
    if ( $warning % 2 != 0 ) {
        s/{warning}/<div id="warning"><p>/;
    }
    elsif ( $warning % 2 == 0 ) {
        s/{warning}/<\/p><\/div>/;
    }

    # Add HTML comments
    $htmlcomment++ if /{htmlcomment}/;
    if ( $htmlcomment % 2 != 0 ) {
        s/{htmlcomment}/<!--/;
    }
    elsif ( $htmlcomment % 2 == 0 ) {
        s/{htmlcomment}/-->/;
    }

    # HTML tables
    $table++ if /{table}/;
    if ( $table % 2 != 0 ) {
        s/{table}/<table>/;
    }
    elsif ( $table % 2 == 0 ) {
        s/{table}/<\/table>/;
    }

    s{\n+}{\n}gis;    # Necessary?

    # Use newlines as an ugly proxy for paragraph breaks
    $para++ if /\n+/;
    if ( $para % 2 != 0 ) {
        s{\n}{</p>}gis unless $para == 1;
    }
    elsif ( $para % 2 == 0 ) {
        s{\n}{<p>}gis;
    }

    s/{indent}//g;
    push @output, $_;
}

if ($wrap) {
    push @output, "</body></html>";
}

for my $line (@output) {
    if ( $line =~ /{toc/ ) {
        my @result  = parse_toc($line);
        my $toc_min = $result[0];
        my $toc_max = $result[1];
        my $toc_pat = $result[2];
        $line = replace_toc_line( $line, $toc_min, $toc_max, $toc_pat );
    }
    say $line;
}

sub eunicize {
    # String -> String
    my $title = shift;
    $title =~ s/ /-/g;
    $title =~ s/-{2,}/-/g;
    $title =~ s/[^-\w]//gi;
    $title .= '.html';
    return lc $title;
}

sub replace_toc_line {
    # String, Int, Int, Regex -> String
    my ( $line, $min, $max, $pat ) = @_;
    my $result = qq{<div id="toc"><strong>On This Page</strong>};

    for my $toc_line (@toc_lines) {
        my $line_level = $toc_line->[0];
        my $line_text  = $toc_line->[1];
        if (( $min <= $line_level
	      &&
	      $line_level <= $max )
            && $line_text !~ $pat )
	  {
            $result .= "$line_text\n";
	  }
    }
    $result .= qq{</div>};
    $line = $result;
    return $line;
}

sub parse_toc {
    # String -> Array
    # {toc:minlevel=3|maxlevel=4|Exclude=.*} -> ($min, $max, $pat)
    my $s = shift;
    my @result = ( $toc_min, $toc_max, $toc_pat );
    if ( $s =~ /\{toc:minlevel=(\d+)\|maxlevel=(\d+)\|exclude=(.*)\}/ ) {
        @result = ( $1, $2, $3 );
    }
    elsif ( $s =~ /\{toc:minlevel=(\d)\|maxlevel=(\d).*/ ) {
        @result = ( $1, $2, "3.14159" );
    }
    elsif ( $s =~ /\{toc:minlevel=(\d).*/ ) {
        @result = ( $1, 10, "3.14159" );
    }
    else {
        return @result;
    }

    return @result;
}

__END__

=head1 NAME

confluence2html - Generate HTML from a proper subset of Confluence wiki markup

=head1 SYNOPSIS

  confluence2html < wiki-file.txt > wiki-file.html

=head1 DESCRIPTION

Confluence2html is a command line filter that takes as its input a
stream of text marked up with a subset of Confluence markup and
produces as its output a stream of HTML text.

The supported subset of Confluence markup is defined as follows:

=over

=item headers

The h1-h6 header format is supported, as in `h2. Introduction'. No
other formatting inside the header text is supported. For example,
`h2. Introduction to {{confluence2html}}' will not work.

=item links

Standard links are supported, e.g., `[Link to other page]'. This will
be rewritten to link to a local file named
`link-to-other-page.html'. If no such file exists, this will be a
broken link until the file is created. The easiest way to do this is
to have a file of Confluence markup named `link-to-other-page.txt',
which is generated in the same directory using a tool such as C<make>
(or a shell script, or even another Perl script!).

External links are supported as expected, e.g.,

    [Perl home page|http://www.perl.org].

However, Confluence space keys are not allowed. This is in part
because the concept of ``spaces'' has no meaning in terms of processing a
stream of text. Such a feature could be added by a more sophisticated
application built by using/modifying this script.

Finally, links do not automatically have line breaks inserted
afterward. This is to allow you to embed these links in regular
text. If you want to use them as functional subheaders or miniature
tables of contents (without using the `toc' macro), put them in a
bulleted list.

=item macros

A few macros are supported, but only as single tags on their
own line. For example,

    {info}
    Have some informative text!
    {info}.

No arguments of the form `{info:title=FOO}' are supported.

Supported macros include:

=over

=item code

=item info

=item tip

=item note

=item warning

=item htmlcomment

=item table

=item toc

=back

Note that these macros generate C<div> tags with class names that
correspond to the macro name for easy CSS styling. For example:

    <div id="info"><p>
    These instructions assume that you have already installed and
    correctly configured... For more information, see ...
    </p></div>

See below for more information about the `toc' macro.

=item table of contents macro

Prints a table of contents comprised of selected headers on the page,
inside a `div' with a `toc' id, e.g. `<div id =``toc''>'. A subset of
the arguments to the `toc' macro are supported: `minlevel',
`maxlevel', and `exclude' -- in that order. In other words, you must
use the `toc' macro in one of the following ways:

=over

=item `{toc}'

Prints a table of contents using all headers on the page.

=item `{toc:minlevel=$N|maxlevel=$M|exclude=$REGEX}'

Where C<$N> and C<$M> are integers between 1 and 6, and C<$REGEX> is a
perl regular expression -- note that the regular expression is not
surrounded by quotes. This prints a table of contents with a minimum
header size of C<$N> and a maximum header size of C<$M>, with any
headers matching C<$REGEX> being excluded.

=item `{toc:minlevel=$N|maxlevel=$M}'

Where C<$N> and C<$M> are integers between 1 and 6. This prints a
table of contents with a minimum header size of C<$N> and a maximum
header size of C<$M>.

=item `{toc:minlevel=$N}'

Where C<$N> is an integer between 1 and 6. This prints a
table of contents with a minimum header size of C<$N>.

=back

=item lists

Only unordered lists are supported at this time. This should be fixed
in the future.

Furthermore, no bold items can be used as list elements; the following
will not work:

    `* *First item*...'

=item line breaks

The line breaks that appear in the HTML output are those that appear
in the text file. There is no support for `\\' (Confluence syntax for
a forced line break).

=item tables

Tables are supported. The only requirement is that you must wrap the
table itself in the `{table}' macro. (This decision is a compromise
based on the fact that it makes tables simpler to parse.)

=back

=head1 COMMAND LINE ARGUMENTS

=over

=item --stylesheet, -s

The location of the CSS stylesheet, e.g.,

    ./confluence2html --stylesheet=bootstrap.css

=item --wrap

Whether to wrap the body of the resulting HTML in `html', `head', and
`body' tags. This includes a link to the stylesheet specified by the
`--stylesheet' option, so if you use this argument you probably want
to specify a stylesheet.

=back

=head1 BUGS

Many bugs are lurking in this code; it's a total hack. On the roadmap:
tests, refactoring, and perhaps even real parsing. Please open a
Github issue to report a bug or request a feature:

L<http://github.com/rmloveland/confluence2html>

=head1 AUTHOR

Rich Loveland, L<r@rmloveland.com>
