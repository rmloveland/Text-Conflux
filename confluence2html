#!/usr/bin/env perl

use strict;
use warnings;
use autodie;
use feature qw< say state >;
use Getopt::Long;

#--------------------------------------------------------------------
# Option parsing.

my ( $stylesheet, $wrap );
GetOptions(
    "stylesheet:s" => \$stylesheet,
    "wrap"         => \$wrap,
);

#--------------------------------------------------------------------
# Global Variables.

my @output;
my @toc_lines;
my $toc_min = 0;
my $toc_max = 10;
my $toc_exclude_pat;

my $wiki_link_pat   = "&|/\-:. ";
my $header_link_pat = $wiki_link_pat . "#";

my $external_link_text_pat   = "\\.\\?#!\\- ";
my $external_link_target_pat = $external_link_text_pat . "#_/:=&";

my $image_pat = "\\-|\\. ";

my $bold_pat   = qq{\\- &,:'?>\\.\\"};
my $italic_pat = $bold_pat;

my $panel_pat = "{panel.*";
my $toc_pat = "{toc.*";

$wrap++ if $stylesheet;

if ($wrap) {
    push @output,
      qq{<html><head><link href="$stylesheet" rel="stylesheet"></head><body>\n};
}

#-------------------------------------------------------------------
# Ye Olde Main Input Processing Loop.

LINE: while (<>) {
    state $code        = 0;
    state $info        = 0;
    state $tip         = 0;
    state $note        = 0;
    state $warning     = 0;
    state $htmlcomment = 0;
    state $table       = 0;

    next LINE if /$panel_pat/;

    if (/$toc_pat/) {
        push @output, $_;
        next LINE;
    }

    ## We wrap the link-making code below in a DO block so that text
    ## is never modified in any way while we're inside a `{code}'
    ## block.  This change was prompted by an attempt to format some
    ## Objective-C code in one of our projects.

    do {
      # External links.
      s{\[([[:alnum:]$external_link_text_pat]+)\|([[:alnum:]$external_link_target_pat]+)\]}
       {<a href="$2">$1</a>}gis;

      # Internal links, e.g. `[Mobile Ad Call Reference]'.  See below
      # for the definition of EUNICIZE.
      s{\[([[:alnum:]$wiki_link_pat]+)\]}
       {qq[<a href="] . eunicize($1) . qq[">$1</a>]}gise;

      # Links to headers on the same page.  We don't support anchors
      # (yet).
      s{\[#([[:alnum:]$header_link_pat]+)\]}
       {<a href="#$1">$1</a>}gis;

      # Images.
      s{^\!([[:alnum:]$image_pat]+.(png|jpg)).*\!}
       {<br /><br /><img src="../img/$1"/><br /><br />}gis;

      # Bold elements (Sometimes they occur at the beginning of a
      # line, so we process them before we get to the list section
      # below.
      s/\*([[:alnum:]$bold_pat]+)\*/<strong>$1<\/strong>/g;
      s/^\*([[:alnum:]$bold_pat]+)\*/<strong>$1<\/strong>/g;

      # Lists of links, optionally followed by a colon or slash, then
      # descriptive text.
      s/^\* ?(<a href.*<\/a>)([ :\-]?.*)/\<li>$1$2<\/li>/g;

      # Lists of non-link items.
      s/^\* ?(.*)$/\<li>$1<\/li>/g;
      s/^\- ?(.*)$/\<li>$1<\/li>/g; # Use the `-' char for bulleted
                                    # lists of bold items. Should we
                                    # bother supporting the other
                                    # syntax?

      # Italic elements.
      s/ \_([[:alnum:]$italic_pat]+)\_([ \.])/ <em>$1<\/em>$2/g;

      # Tables.  These still have to be wrapped in a `{table}' macro.
      # Hopefully not for long.
      s{^\|\|}{<tr><th>}gis;    # Beginning of table
      s{\|\| ?\n}{</th></tr>}gis;
      s{\|\|}{</th><th>}gis;         # Middle of columns
      s{\| ?\n}{</td></tr>}gis;
      s{^\|}{<tr><td>}gis;
      s{\|}{</td><td>}gis;

    } unless $code % 2 != 0;

    # Process headers, 1-6.  We add an appropriate ID to each header's
    # LI tag so that we can use CSS's TEXT-INDENT to create a nice
    # indentation in the table of contents.

    if (/h([0-9]). (.*)$/) {
        my $new =
          qq[<h$1><a name="$2">$2</a></h$1>];
        my $toc_line = qq[<li class="h$1"><a href="#$2">$2</a></li>];
        push @toc_lines, [ $1, $toc_line ];
        s/h$1. (.*)$/$new/;
    }

    # Monospace.
    s/{{([\\!\@\$0-9\+A-Z\.,\-\/>a-z_=:"\(\) \<\>\n]+)}}/<code>$1<\/code>/g;

    # Same-line code blocks.
    s/\{code\}\n?(.*[\n]?)\n?\{code\}/<pre>$1<\/pre>/s;

    # Multiline code blocks.
    $code++ if /\{code\}/;

    if ( $code % 2 != 0 ) {
      # Escape embedded HTML/XML tags inside the code block.  This was
      # necessitated by some XML build cruft for an Android project.
        s/</&lt;/g;
        s/>/&gt;/g;
        s{\n}{}g;
        s/\{code\}/<pre>/;
    }
    elsif ( $code % 2 == 0 ) {
        s/\{code\}/<\/pre>/;
    }

    # Div-ify the Confluence macros INFO, NOTE, TIP, and WARNING so
    # that we can give them the appropriate colors using CSS.
    $info++ if /{info}/;
    if ( $info % 2 != 0 ) {
        s/{info}/<div class="info">/;
    }
    elsif ( $info % 2 == 0 ) {
        s/{info}/<\/div>/;
    }

    $note++ if /{note}/;
    if ( $note % 2 != 0 ) {
        s/{note}/<div class="note">/;
    }
    elsif ( $note % 2 == 0 ) {
        s/{note}/<\/div>/;
    }

    $tip++ if /{tip}/;
    if ( $tip % 2 != 0 ) {
        s/{tip}/<div class="tip">/;
    }
    elsif ( $tip % 2 == 0 ) {
        s/{tip}/<\/div>/;
    }

    $warning++ if /{warning}/;
    if ( $warning % 2 != 0 ) {
        s/{warning}/<div class="warning">/;
    }
    elsif ( $warning % 2 == 0 ) {
        s/{warning}/<\/div>/;
    }

    # Support HTML comments. This is one of my favorite macros.
    $htmlcomment++ if /{htmlcomment}/;
    if ( $htmlcomment % 2 != 0 ) {
        s/{htmlcomment}/<!--/;
    }
    elsif ( $htmlcomment % 2 == 0 ) {
        s/{htmlcomment}/-->/;
    }

    # HTML tables need to be wrapped in `{table}' tags.
    $table++ if /{table}/;
    if ( $table % 2 != 0 ) {
        s/{table}/<table>/;
    }
    elsif ( $table % 2 == 0 ) {
        s/{table}/<\/table>/;
    }

    s{\n+}{\n}gis;    # Necessary?

    # Since all the other transformations are complete, we now know
    # that we can wrap lines of text that are surrounded by newlines
    # in paragraph tags (with a few simple exceptions).

    if (/(<\/?h[0-9]>|<\/?pre>|<\/?table>|<\/?li>|<\/?div)/) {
      push @output, $_;
      next LINE;
    }

    unless($_ =~ /^(<h[0-9]|<\/?pre>|<\/?table><\/?div)/) {
      s{^([\w <\/>\.,'\_\-!=:"&#]+\n+)}
       {<p>$1</p>}g;
    }

    s/{indent}//g;
    push @output, $_;
}

if ($wrap) {
    push @output, "</body></html>";
}

#-------------------------------------------------------------------
# Ye Olde Main Output Processing Loop.

for my $line (@output) {
    if ( $line =~ /$toc_pat/ ) {
        my @result  = parse_toc($line);
        my $toc_min = $result[0];
        my $toc_max = $result[1];
        my $toc_exclude_pat = $result[2];
        $line = replace_toc_line( $line, $toc_min, $toc_max, $toc_exclude_pat );
    }
    say $line;
}

#-------------------------------------------------------------------
# Turn a [Wiki Link] into a <a href="wiki-link.html">Wiki Link</a>.

sub eunicize {
    # String -> String
    my $title = shift;
    $title =~ s/ /-/g;
    $title =~ s/-{2,}/-/g;
    $title =~ s/[^-\w]//gi;
    $title .= '.html';
    return lc $title;
}

#-------------------------------------------------------------------
# Table of contents processing goes here.

sub replace_toc_line {
    # String, Int, Int, Regex -> String
    my ( $line, $min, $max, $pat ) = @_;
    my $result = qq{<div id="toc"><ul>};

    for my $toc_line (@toc_lines) {
        my $line_level = $toc_line->[0];
        my $line_text  = $toc_line->[1];
        if (( $min <= $line_level
	      &&
	      $line_level <= $max )
            && $line_text !~ $pat )
	  {
            $result .= "$line_text\n";
	  }
    }
    $result .= qq{</ul></div>};
    $line = $result;
    return $line;
}

sub parse_toc {
    # String -> Array
    # {toc:minlevel=3|maxlevel=4|Exclude=.*} -> ($min, $max, $pat)
    my $s = shift;
    my @result = ( $toc_min, $toc_max, $toc_exclude_pat );
    if ( $s =~ /\{toc:minlevel=(\d+)\|maxlevel=(\d+)\|exclude=(.*)\}/ ) {
        @result = ( $1, $2, $3 );
    }
    elsif ( $s =~ /\{toc:minlevel=(\d)\|maxlevel=(\d).*/ ) {
        @result = ( $1, $2, "3.14159" );
    }
    elsif ( $s =~ /\{toc:minlevel=(\d).*/ ) {
        @result = ( $1, 10, "3.14159" );
    }
    else {
        return @result;
    }

    return @result;
}

__END__

=head1 NAME

confluence2html - Generate HTML from a proper subset of Confluence wiki markup

=head1 SYNOPSIS

  confluence2html < wiki-file.txt > wiki-file.html

=head1 DESCRIPTION

Confluence2html is a command line filter that takes as its input a
stream of text marked up with a subset of Confluence markup and
produces as its output a stream of HTML text.

The supported subset of Confluence markup is defined as follows:

=over

=item headers

The h1-h6 header format is supported, as in `h2. Introduction'. No
other formatting inside the header text is supported. For example,
`h2. Introduction to {{confluence2html}}' will not work.

=item links

Standard links are supported, e.g., `[Link to other page]'. This will
be rewritten to link to a local file named
`link-to-other-page.html'. If no such file exists, this will be a
broken link until the file is created. The easiest way to do this is
to have a file of Confluence markup named `link-to-other-page.txt',
which is generated in the same directory using a tool such as C<make>
(or a shell script, or even another Perl script!).

External links are supported as expected, e.g.,

    [Perl home page|http://www.perl.org].

However, Confluence space keys are not allowed. This is in part
because the concept of ``spaces'' has no meaning in terms of processing a
stream of text. Such a feature could be added by a more sophisticated
application built by using/modifying this script.

Finally, links do not automatically have line breaks inserted
afterward. This is to allow you to embed these links in regular
text. If you want to use them as functional subheaders or miniature
tables of contents (without using the `toc' macro), put them in a
bulleted list.

=item macros

A few macros are supported, but only as single tags on their
own line. For example,

    {info}
    Have some informative text!
    {info}.

No arguments of the form `{info:title=FOO}' are supported.

Supported macros include:

=over

=item code

=item info

=item tip

=item note

=item warning

=item htmlcomment

=item table

=item toc

=back

Note that these macros generate C<div> tags with class names that
correspond to the macro name for easy CSS styling. For example:

    <div class="info">
    These instructions assume that you have already installed and
    correctly configured... For more information, see ...
    </div>

See below for more information about the `toc' macro.

=item table of contents macro

Prints a table of contents comprised of selected headers on the page,
inside a `div' with a `toc' id, e.g. `<div id =``toc''>'. A subset of
the arguments to the `toc' macro are supported: `minlevel',
`maxlevel', and `exclude' -- in that order. In other words, you must
use the `toc' macro in one of the following ways:

=over

=item `{toc}'

Prints a table of contents using all headers on the page.

=item `{toc:minlevel=$N|maxlevel=$M|exclude=$REGEX}'

Where C<$N> and C<$M> are integers between 1 and 6, and C<$REGEX> is a
perl regular expression -- note that the regular expression is not
surrounded by quotes. This prints a table of contents with a minimum
header size of C<$N> and a maximum header size of C<$M>, with any
headers matching C<$REGEX> being excluded.

=item `{toc:minlevel=$N|maxlevel=$M}'

Where C<$N> and C<$M> are integers between 1 and 6. This prints a
table of contents with a minimum header size of C<$N> and a maximum
header size of C<$M>.

=item `{toc:minlevel=$N}'

Where C<$N> is an integer between 1 and 6. This prints a
table of contents with a minimum header size of C<$N>.

=back

=item lists

Only unordered lists are supported at this time. This should be fixed
in the future.

Furthermore, no bold items can be used as list elements; the following
will not work:

    `* *First item*...'

=item line breaks

The line breaks that appear in the HTML output are those that appear
in the text file. There is no support for `\\' (Confluence syntax for
a forced line break).

=item tables

Tables are supported. The only requirement is that you must wrap the
table itself in the `{table}' macro. (This decision is a compromise
based on the fact that it makes tables simpler to parse.)

=back

=head1 COMMAND LINE ARGUMENTS

=over

=item --stylesheet, -s

The location of the CSS stylesheet, e.g.,

    ./confluence2html --stylesheet=bootstrap.css

If you pass this argument, --wrap is automatically passed as well.

=item --wrap

Whether to wrap the body of the resulting HTML in `html', `head', and
`body' tags. This includes a link to the stylesheet specified by the
`--stylesheet' option, so if you use this argument you probably want
to specify a stylesheet.

=back

=head1 BUGS

Many bugs are lurking in this code; it's a total hack. On the roadmap:
tests, refactoring, and perhaps even real parsing. Please open a
Github issue to report a bug or request a feature:

L<http://github.com/rmloveland/confluence2html>

=head1 AUTHOR

Rich Loveland, L<r@rmloveland.com>
